#   Created by Georgiy Maruzhenko on 2019-06-13.
#   Copyright Â© 2019 Georgiy Maruzhenko. All rights reserved.

import numpy as np
from numpy import sqrt, sin, cos, pi, e, sqrt, isclose
import matplotlib.pyplot as plt
from scipy.integrate import trapz, quad

# https://en.wikipedia.org/wiki/Atmosphere_of_Earth
# http://www.spectralcalc.com/blackbody/integrate_planck.html
# https://ecee.colorado.edu/~ecen5555/SourceMaterial/ShockleyQueisserLimit1212.pdf

# http://halas.rice.edu/conversions

k = 1.38064852 * 10 ** -23  # botzman m^2*kg/s^2/K
k_ev = 8.617 * 10 ** -5  # eV/K
h = 6.62607004 * 10 ** -34  # m^2 kg / s
c = 3 * 10 ** 8  # m/s
T_SUN = 5800  # K
R_SUN = 695510 * 1000  # m
R_ORBIT = 149.60 * 10 ** 9  # m
SIGMA = 5.67 * 10 ** -8  # W / (m^2 K^2)
R_EARTH = 6370 * 1000  # m
DIVIDE_FACTOR = 4  # to get wats per meter
ATMOSPHERE_HEIGHT = 400 * 1000  # m
R_EARTH_ATMOSPHERE = R_EARTH + ATMOSPHERE_HEIGHT  # m
N_M_UNITS = 10 ** 9  # m
U_M_UNITS = 10 ** 6  # m
M_TO_EV = 1240 / N_M_UNITS  # nm per 1 ev
ONE_NM = 1 / N_M_UNITS
END_SOLAR_SPECTRUM = 3 * 10 ** -6
NORMALIZE_EV_Y = 10*N_M_UNITS**11

# output in W/sr/m^3
def spectral_radiance(wlength):
    result = 2 * h * c ** 2 / (wlength ** 5 * (e ** (h * c / (wlength * k * T_SUN)) - 1))
    return result


def ev_spectral_radiance(E):
    result = 2 * E ** 4 / (h ** 4 * c ** 3 * (e ** (E / (k_ev * T_SUN)) - 1))
    return result


def plot_spectral_radiance():
    spectrum = np.linspace(0, )
    plt.plot(spectrum, spectral_radiance(spectrum))
    plt.show()


# output in W/m^3
def mean_solar_irradiance(wlength):
    return spectral_radiance(wlength) * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR


def ev_mean_solar_irradiance(E):
    return ev_spectral_radiance(E) * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR/NORMALIZE_EV_Y


def mean_solar_irradiance_with_bandgap(wlength, wcutoff):
    spect_rad_band = 2 * h * c ** 2 / (wlength ** 4 * (e ** (h * c / (wlength * k * T_SUN)) - 1)) / wcutoff
    return spect_rad_band * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR


def ev_mean_solar_irradiance_with_bandgap(E, E_gap):
    spect_rad_band = 2 * E ** 3 / (h ** 4 * c ** 3 * (e ** (E / (k_ev * T_SUN)) - 1)) * E_gap
    return spect_rad_band * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR /NORMALIZE_EV_Y


def plot_mean_solar_irradiance_earth_nm():
    spectrum = np.linspace(0, 3 * 10 ** -6, 1000)
    plt.plot(spectrum * N_M_UNITS, mean_solar_irradiance(spectrum) / N_M_UNITS)
    plt.title('Irradiance Sun on Earth')
    plt.xlabel('wavelength (nm)')
    plt.ylabel('W/(m^2*nm) ')
    plt.legend(['Mean Solar Irradiance at Earth'])
    plt.show()


def plot_mean_solar_irradiance_earth_ev():
    spectrum = np.linspace(100 / N_M_UNITS, 3 * 10 ** -6, 1000)
    reversed_spectrum = list(reversed(M_TO_EV / spectrum))
    reversed_mean_solar_irradiance = list(reversed(mean_solar_irradiance(spectrum) * M_TO_EV))
    plt.plot(reversed_spectrum, reversed_mean_solar_irradiance)
    plt.title('Irradiance Sun on Earth')
    plt.xlabel('Photon Energy [ev]')
    plt.ylabel('Spectral irradiance [W/(m^2*ev)] ')
    plt.legend(['Mean Solar Irradiance at Earth'])
    plt.show()


def show_solar_intensity():
    radiance_integrated = 2 * pi ** 4 * k ** 4 * T_SUN ** 4 / (15 * h ** 3 * c ** 2)  # W/m^2/sr
    solar_intensity_at_earth = radiance_integrated * pi * R_SUN ** 2 / R_ORBIT ** 2
    print("solar intesity = ", solar_intensity_at_earth, "W/m^2")


# prints the theoretical efficeny for the photo cell and show the plot of power generated vs total power from sun
# this assumes that 3/4 solar power lost due to atmopsthere and other factors - change in DIVIDE_FACTOR
# creates photovoltec plots given a bangap in eV
def plot_bandgap_nm(bangap_cutoff):

    spectrum = np.arange(ONE_NM, END_SOLAR_SPECTRUM, ONE_NM)
    spectrum_to_cutoff = np.arange(ONE_NM, bangap_cutoff, ONE_NM)
    power_generated = mean_solar_irradiance_with_bandgap(spectrum_to_cutoff, bangap_cutoff) / N_M_UNITS

    #append zeros where energy is to low for power generation
    zeros = np.zeros(len(spectrum) - len(spectrum_to_cutoff))
    extended = np.concatenate((power_generated, zeros))

    total_spectrum = mean_solar_irradiance(spectrum) / N_M_UNITS
    plt.plot(spectrum * N_M_UNITS, extended)
    plt.plot(spectrum * N_M_UNITS, total_spectrum)

    total_area = trapz(total_spectrum, dx=ONE_NM)
    power_area = trapz(power_generated, dx=ONE_NM)

    print("Theoretical Efficency for bangap ", bangap_cutoff * N_M_UNITS, "nm is", power_area / total_area * 100,
          "percent")

    plt.title(['Photovoltaecs for bandgap', bangap_cutoff * N_M_UNITS, ' nm'])
    plt.xlabel('wavelength (nm)')
    plt.ylabel('W/(m^2*nm) ')
    plt.legend(['power generated by cell', 'total available power'])
    plt.show()


# creates photovoltec plots given a bangap in eV
def plot_bandgap_ev(e_gap):
    dx = 0.01

    spectrum = np.arange(0.001, 7, dx)
    spectrum_cutoff = np.arange(e_gap, 7, dx)
    total_spectrum = ev_mean_solar_irradiance(spectrum)
    power_generated = ev_mean_solar_irradiance_with_bandgap(spectrum_cutoff, e_gap)

    #append zeros where energy is to low for power generation
    zeros = np.zeros(len(spectrum) - len(spectrum_cutoff))
    extended = np.concatenate((zeros, power_generated))

    total_area = trapz(total_spectrum, dx=dx)
    power_area = trapz(power_generated, dx=dx)

    print("Theoretical Efficency for bangap ", e_gap, "eV is", power_area / total_area * 100,
          "percent")
    plt.plot(spectrum, extended)
    plt.plot(spectrum, total_spectrum)

    plt.title(['Photovoltaecs for bandgap', e_gap, ' eV'])
    plt.xlabel('Energy (ev)')
    plt.ylabel('W/(m^2*ev) ')
    plt.legend(['power generated by cell', 'total available power'])
    plt.show()


plot_bandgap_ev(1.5)
plot_bandgap_nm(826.56129 / N_M_UNITS)