#   Created by Georgiy Maruzhenko on 2019-06-13.
#   Copyright Â© 2019 Georgiy Maruzhenko. All rights reserved.

import numpy as np
from numpy import sqrt, sin, cos, pi, e, sqrt, isclose
import matplotlib.pyplot as plt
from scipy.integrate import trapz, quad

# https://en.wikipedia.org/wiki/Atmosphere_of_Earth
# http://www.spectralcalc.com/blackbody/integrate_planck.html
# https://ecee.colorado.edu/~ecen5555/SourceMaterial/ShockleyQueisserLimit1212.pdf

k = 1.38064852 * 10 ** -23  # botzman m^2*kg/s^2/K
k_ev = 8.617 * 10 ** -5  # eV/K
h = 6.62607004 * 10 ** -34  # m^2 kg / s
c = 3 * 10 ** 8  # m/s
T_SUN = 5800  # K
R_SUN = 695510 * 1000  # m
R_ORBIT = 149.60 * 10 ** 9  # m
SIGMA = 5.67 * 10 ** -8  # W / (m^2 K^2)
R_EARTH = 6370 * 1000  # m
DIVIDE_FACTOR = 4  # to get wats per meter
ATMOSPHERE_HEIGHT = 400 * 1000  # m
R_EARTH_ATMOSPHERE = R_EARTH + ATMOSPHERE_HEIGHT  # m
N_M_UNITS = 10 ** 9  # m
U_M_UNITS = 10 ** 6  # m
M_TO_EV = 1240 / N_M_UNITS  # nm per 1 ev
ONE_NM = 1 / N_M_UNITS
END_SOLAR_SPECTRUM = 3 * 10 ** -6

# output in W/sr/m^3
def spectral_radiance(wlength):
    result = 2 * h * c ** 2 / (wlength ** 5 * (e ** (h * c / (wlength * k * T_SUN)) - 1))
    return result


def plot_spectral_radiance():
    spectrum = np.linspace(0, )
    plt.plot(spectrum, spectral_radiance(spectrum))
    plt.show()


# output in W/m^3
def mean_solar_irradiance(wlength):
    return spectral_radiance(wlength) * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR


def mean_solar_irradiance_with_bandgap(wlength, wcutoff):
    spect_rad_band = 2 * h * c ** 2 / (wlength ** 4 * (e ** (h * c / (wlength * k * T_SUN)) - 1)) / wcutoff
    return spect_rad_band * pi * R_SUN ** 2 / R_ORBIT ** 2 / DIVIDE_FACTOR


def plot_mean_solar_irradiance_earth_nm():
    spectrum = np.linspace(0, 3 * 10 ** -6, 1000)
    plt.plot(spectrum * N_M_UNITS, mean_solar_irradiance(spectrum) / N_M_UNITS)
    plt.title('Irradiance Sun on Earth')
    plt.xlabel('wavelength (nm)')
    plt.ylabel('W/(m^2*nm) ')
    plt.legend(['Mean Solar Irradiance at Earth'])
    plt.show()


def plot_mean_solar_irradiance_earth_ev():
    spectrum = np.linspace(100 / N_M_UNITS, 3 * 10 ** -6, 1000)
    reversed_spectrum = list(reversed(M_TO_EV / spectrum))
    reversed_mean_solar_irradiance = list(reversed(mean_solar_irradiance(spectrum) * M_TO_EV))
    plt.plot(reversed_spectrum, reversed_mean_solar_irradiance)
    plt.title('Irradiance Sun on Earth')
    plt.xlabel('Photon Energy [ev]')
    plt.ylabel('Spectral irradiance [W/(m^2*ev)] ')
    plt.legend(['Mean Solar Irradiance at Earth'])
    plt.show()


def show_solar_intensity():
    radiance_integrated = 2 * pi ** 4 * k ** 4 * T_SUN ** 4 / (15 * h ** 3 * c ** 2)  # W/m^2/sr
    solar_intensity_at_earth = radiance_integrated * pi * R_SUN ** 2 / R_ORBIT ** 2
    print("solar intesity = ", solar_intensity_at_earth, "W/m^2")


# produces a plot of useful power given a band gap energy threshold
def plot_photovoltaics(E_thresh):
    nm_cutoff = E_thresh * M_TO_EV
    spectrum = np.linspace(100 / N_M_UNITS, nm_cutoff, 100)
    print(nm_cutoff)
    reversed_spectrum = list(reversed(M_TO_EV / spectrum))
    reversed_mean_solar_irradiance = list(reversed(mean_solar_irradiance(spectrum) * M_TO_EV * (1240)))
    # integral = trapz(reversed_mean_solar_irradiance, x=reversed_spectrum)

    plt.plot(reversed_spectrum, reversed_mean_solar_irradiance)
    plt.xlabel(' Energy [ev]')
    plt.ylabel('Power  [W/(m^2*ev)] ')
    plt.show()


def plot_bandgap_nm():
    # input bangap here
    bangap_cutoff = 1240 / N_M_UNITS

    spectrum = np.arange(ONE_NM, END_SOLAR_SPECTRUM, ONE_NM)
    spectrum_to_cutoff = np.arange(ONE_NM, bangap_cutoff, ONE_NM)
    power_generated = mean_solar_irradiance_with_bandgap(spectrum_to_cutoff, bangap_cutoff) / N_M_UNITS

    zeros = np.zeros(len(spectrum) - len(spectrum_to_cutoff))
    extended = np.concatenate((power_generated, zeros))
    total_spectrum = mean_solar_irradiance(spectrum) / N_M_UNITS
    plt.plot(spectrum * N_M_UNITS, extended)
    plt.plot(spectrum * N_M_UNITS,total_spectrum)

    total_area = trapz(total_spectrum, dx=ONE_NM)
    power_area = trapz(power_generated, dx=ONE_NM)
    print(power_area/total_area)

    plt.title(['Photovoltaecs for bandgap', bangap_cutoff * N_M_UNITS, ' nm'])
    plt.xlabel('wavelength (nm)')
    plt.ylabel('W/(m^2*nm) ')
    plt.legend(['power generated by cell', 'total available power'])
    plt.show()


plot_bandgap_nm()

# plot_photovoltaics(1)
#
# def get_efficiency(E_thresh):
#     total = intergrate_power_total()
#     above_bandgap = intergrate_power(E_thresh)
#     print(total)
#     print(above_bandgap)
#     efficency = above_bandgap / total
#     return efficency
#
#
# def intergrate_power(E_thresh):
#     nm_cutoff = 1240 / E_thresh / N_M_UNITS
#     spectrum = np.linspace(100 / N_M_UNITS, nm_cutoff, 1000)
#     reversed_spectrum = list(reversed(M_TO_EV / spectrum))
#     reversed_mean_solar_irradiance = list(reversed(mean_solar_irradiance(spectrum) * M_TO_EV))
#     integral = trapz(reversed_mean_solar_irradiance, x=reversed_spectrum)
#     plt.plot(reversed_spectrum, reversed_mean_solar_irradiance)
#     plt.title('Irradiance Sun on Earth')
#     plt.xlabel(' Energy [ev]')
#     plt.ylabel('Power  [W/(m^2*ev)] ')
#     plt.show()
#     return integral
#
#
# # all area under curve
# def intergrate_power_total():
#     spectrum = np.linspace(100 / N_M_UNITS, 3 * 10 ** -6, 1000)
#     reversed_spectrum_evs = list(reversed(M_TO_EV / spectrum))
#     reversed_mean_solar_irradiance = list(reversed(mean_solar_irradiance(spectrum) * M_TO_EV))
#     integral = trapz(reversed_mean_solar_irradiance, x=reversed_spectrum_evs)
#     return integral
#
# plot_mean_solar_irradiance_earth_ev()
# def intergrand(E):
#     step =  2*pi*E**2/(h**3*c**2*(e**(E/(k_ev*T_SUN))-1))
#     print(step)
#     return step

# def efficency_photovoltaecs(Egap):
#     top = Egap

# print(get_efficiency(2))
# plot_photovoltaics(1)


# def power_past_bandgap(E):
#     result = 2 * pi * E ** 2 / (h ** 3 * c ** 2 * (e ** (E / (k_ev * T_SUN)) - 1))
#     return result
#
# def power_past_bandgap_total(E):
#     result = 2 * pi * E ** 3 / (h ** 3 * c ** 2 * (e ** (E / (k_ev * T_SUN)) - 1))
#     return result
#
# E_GAP = 1
# spectrum = np.linspace(0, 5)
# integral_top = power_past_bandgap(spectrum)*E_GAP
# integral_botom = power_past_bandgap_total(spectrum)
# plt.plot(spectrum,integral_top)
# plt.show()
